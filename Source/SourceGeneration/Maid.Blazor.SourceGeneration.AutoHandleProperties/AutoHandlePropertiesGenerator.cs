using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Xml.Linq;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Maid.Blazor.SourceGeneration.AutoHandle
{
	internal record ClassModel
	{
		public string ClassName { get; set; }
		public string Namespace { get; set; }
		public string ClassAccessibility { get; set; }
		public EquatableList<PropertyInfo> Properties { get; set; } = new();

		
	}internal record PropertyInfo
	{
		public string PropertyName { get; set; }
		public string ReturnType { get; set; }
		public bool IsPartial { get; set; }
		public bool IgnoreAutoHandle { get; set; }
	}
	
	[Generator(LanguageNames.CSharp)]
	public class AutoHandlePropertiesGenerator : IIncrementalGenerator
	{
		public const string PropertyMarkerAttributeName = "IgnoreAutoHandleAttribute";
		public const string PropertyMarkerAttributeNamespace = "Maid.Blazor.SourceGeneration";
		public const string PropertyMarkerAttributeFullname = $"{PropertyMarkerAttributeNamespace}.{PropertyMarkerAttributeName}";
		public const string PropertyMarkerAttributeMarkup = $$"""
// <auto-generated />

namespace {{PropertyMarkerAttributeNamespace}};
[System.AttributeUsage(System.AttributeTargets.Property, AllowMultiple = false)]
public class {{PropertyMarkerAttributeName}} : System.Attribute;
""";

		public const string ClassMarkerAttributeName = "EnableAutoHandleAttribute";
		public const string ClassMarkerAttributeNamespace = "Maid.Blazor.SourceGeneration";
		public const string ClassMarkerAttributeFullname = $"{ClassMarkerAttributeNamespace}.{ClassMarkerAttributeName}";
		public const string ClassMarkerAttributeMarkup = $$"""
// <auto-generated />

namespace {{ClassMarkerAttributeNamespace}};
[System.AttributeUsage(System.AttributeTargets.Class, Inherited = true, AllowMultiple = false)]
public class {{ClassMarkerAttributeName}} : System.Attribute
{
	public string BeforeHandleMethodName { get; set; } = string.Empty;
	public string AfterHandleMethodName { get; set; } = string.Empty;
}
""";
		public const string AssignPropertiesMethodName = "AssignProperties";
		public void Initialize(IncrementalGeneratorInitializationContext context)
		{
			context.RegisterPostInitializationOutput(RegisterAttributes);

			var suitableClasses = GetSuitableClasses(context);

			context.RegisterSourceOutput(
				source: suitableClasses.Where(o=>o is not null),
				action: Run
			);
		}
		internal static void RegisterAttributes(IncrementalGeneratorPostInitializationContext ctx)
		{
			ctx.AddSource(
				hintName: $"{ClassMarkerAttributeFullname}.g.cs",	
				sourceText: SourceText.From(ClassMarkerAttributeMarkup,Encoding.UTF8)
			);
			ctx.AddSource(
				hintName: $"{PropertyMarkerAttributeFullname}g.cs",
				sourceText: SourceText.From(PropertyMarkerAttributeMarkup, Encoding.UTF8)
			);
		}
		internal static bool Selector(SyntaxNode node, CancellationToken ct)
			=> true;
		internal static ClassModel Transform(GeneratorAttributeSyntaxContext ctx, CancellationToken ct)
		{ 
			if (ctx.TargetNode is not ClassDeclarationSyntax cds)
				return null;
			var properties = cds.DescendantNodes().OfType<PropertyDeclarationSyntax>();
			if (properties.Count() <= 0)
				return null;

			var clsmodel = new ClassModel()
			{
				ClassName = ctx.TargetSymbol.Name.ToString(),
				Namespace = ctx.TargetSymbol.ContainingNamespace.ToDisplayString(),
				ClassAccessibility = ctx.TargetSymbol.DeclaredAccessibility switch
				{
					Accessibility.Public => "public",
					Accessibility.Private => "private",
					Accessibility.Protected => "protected",
					Accessibility.Internal => "internal",
					_ => throw new InvalidOperationException("Currently only supporting public, private, protected and internal as accessibility.")  
				}
			};
			static bool isParameterAttribute(string name)
			{
				return name.Equals("Parameter", StringComparison.OrdinalIgnoreCase);
			}
			static bool isIgnoreAutoHandleAttribute(string name)
			{
				return name.Equals(PropertyMarkerAttributeName.Replace("Attribute",""), StringComparison.OrdinalIgnoreCase);
			}
			foreach (var property in properties)
			{
				
				var attributes = property.AttributeLists
				.SelectMany(al => al.Attributes);

				if (attributes.Any(attr => isParameterAttribute(attr.Name.ToString())))
				{
					var propInfo = new PropertyInfo()
					{
						PropertyName = property.Identifier.ToString(),
						ReturnType = property.Type.ToString(),
						IsPartial = property.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)),
						IgnoreAutoHandle = attributes.Any(attr=> 
						isIgnoreAutoHandleAttribute(attr.Name.ToString())
						)
					};
					clsmodel.Properties.Add(propInfo);
				}
			}
			if (clsmodel.Properties.Count <= 0)
				return null;
			return clsmodel;
		}
		internal static void Run(SourceProductionContext ctx, ClassModel model)
		{
			string getPropertyCode(PropertyInfo property)
			{
				return 
$$"""
public partial {{property.ReturnType}} {{property.PropertyName}} { get; set { if( field.Equals(value) is false ) field = value;} }
""";
			}


			var code = 
$$"""
namespace {{model.Namespace}};

{{model.ClassAccessibility}} partial class {{model.ClassName}}
{
	{{string.Join("\n\t",model.Properties.Where(prop=>
															  prop.IsPartial is true && prop.IgnoreAutoHandle is false
															  ).Select(getPropertyCode))}}

	protected override void {{AssignPropertiesMethodName}}(Microsoft.AspNetCore.Components.ParameterView parameters)
	{
		base.{{AssignPropertiesMethodName}}(parameters);
		{{string.Join("\n\t\t", model.Properties.Select(prop=>$"""this.{prop.PropertyName} = parameters.GetValueOrDefault("{prop.PropertyName}",this.{prop.PropertyName});"""))}}
	}
}
""";
			ctx.AddSource($"{model.Namespace}.{model.ClassName}.g.cs", SourceText.From(code, Encoding.UTF8));
		}
		static IncrementalValuesProvider<ClassModel> GetSuitableClasses( IncrementalGeneratorInitializationContext ctx)
		{
			return ctx.SyntaxProvider.ForAttributeWithMetadataName(
				fullyQualifiedMetadataName: ClassMarkerAttributeFullname,
				predicate: Selector,
				transform: Transform);
		}
		
	}
	
	internal class EquatableList<T> : List<T>, IEquatable<EquatableList<T>>
	{
		public bool Equals(EquatableList<T> other)
		{
			// If the other list is null or a different size, they're not equal
			if (other is null || Count != other.Count)
			{
				return false;
			}

			// Compare each pair of elements for equality
			for (int i = 0; i < Count; i++)
			{
				if (!EqualityComparer<T>.Default.Equals(this[i], other[i]))
				{
					return false;
				}
			}

			// If we got this far, the lists are equal
			return true;
		}

		public override bool Equals(object obj) { return Equals(obj as EquatableList<T>); }


		public override int GetHashCode()
		{
			return this.Select(item => item?.GetHashCode() ?? 0).Aggregate((x, y) => x ^ y);
		}
		public static bool operator ==(EquatableList<T> list1, EquatableList<T> list2)
		{
			return ReferenceEquals(list1, list2)
				|| (list1 is not null && list2 is not null && list1.Equals(list2));
		}
		public static bool operator !=(EquatableList<T> list1, EquatableList<T> list2)
		{
			return !(list1 == list2);
		}
	}
}
