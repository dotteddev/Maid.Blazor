using System;
using System.Collections.Generic;
using System.Data.Common;
using System.Diagnostics;
using System.Linq;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Maid.Blazor.Generators.AutoFillProperties;
using Maid.Blazor;
using Maid.Blazor.Generators;

namespace Maid.Blazor.Generators.AutoFillProperties;
[Generator]
public class AutoFillPropertiesAttributeGenerator : IIncrementalGenerator
{
	private const string Namespace = "Maid.Blazor.Generators.AutoFillProperties";
	private const string AttributeName = "AutoFillPropertiesAttribute";
	private const string FullyQualifiedName = Namespace + "." + AttributeName;
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		context.RegisterPostInitializationOutput(c => c.AddSource($"{FullyQualifiedName}.g.cs", $@"
using System;
namespace {Namespace};
[AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
public class {AttributeName} : Attribute;
"));
	}
}

[Generator]
public class AutoFillPropertiesGeneratorOld : IIncrementalGenerator
{
	private const string Namespace = "Maid.Blazor.Generators.AutoFillProperties";
	private const string AttributeName = "AutoFillPropertiesAttribute";
	private const string FullyQualifiedName = Namespace + "." + AttributeName;

	//void IIncrementalGenerator.Initialize(IncrementalGeneratorInitializationContext context)
	//{
	//	var items = context.SyntaxProvider
	//		.ForAttributeWithMetadataName(
	//			"UIMaid.Core.FillPropertiesAttribute",
	//			static (node, ct) =>
	//			{
	//				if (node is ClassDeclarationSyntax classDeclaration)
	//				{
	//					return true;
	//				}
	//				return false;
	//			},
	//			static (ctx, ct) =>
	//			{
	//				return new ClassInfo
	//				{
	//					ClassName = "test",
	//					Namespace = "test",
	//					Properties = new EquatableList<PropertyInfo>()
	//				};
	//			});
	//}
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{

		var classesToProcess = context.SyntaxProvider
			.ForAttributeWithMetadataName(
				fullyQualifiedMetadataName: FullyQualifiedName,
				predicate: static (node, ct) => node is ClassDeclarationSyntax,
				transform: static (ctx, ct) =>
				{
					Console.WriteLine("Transforming");
					var containingClass = ctx.TargetSymbol;
					var usings = ctx.SemanticModel.SyntaxTree.GetRoot().DescendantNodes().OfType<UsingDirectiveSyntax>().Select(u => u.Name.ToString()).ToList();


					var properties = (ctx.TargetNode as ClassDeclarationSyntax).Members
						.OfType<PropertyDeclarationSyntax>()
						.Where(pds => pds.AttributeLists.SelectMany(al => al.Attributes).Any(attr => (attr.Name as IdentifierNameSyntax).Identifier.Text.Contains("Parameter")))
						.Select(
							property => new AutoFillProperties.AutoFillPropertiesGeneratorOld.PropertyInfo
							{
								Type = property.Type.ToFullString(),
								PropertyName = property.Identifier.ToString(),
								IsCascading =
										property.AttributeLists
													.SelectMany(prop => prop.Attributes)
													.Any(attr => attr.Name.Equals("CascadingParameter"))
							});
					return new AutoFillProperties.AutoFillPropertiesGeneratorOld.ClassInfo
					{
						Usings = [.. usings],
						ClassName = containingClass.Name,
						Namespace = containingClass.ContainingNamespace.ToDisplayString(),
						Properties = [.. properties.ToList()]
					};
				});

		context.RegisterSourceOutput(
			classesToProcess,
			static (context, classInfo) =>
			{
				var statements = classInfo.Properties
					.Select(
						prop => $"""this.{prop.PropertyName} = newProperties.{prop.PropertyName};""");
				context.AddSource(
					$"{classInfo.Namespace}.{classInfo.ClassName}.g.cs",
					$@"
// <auto-generated />
{string.Join("\n", classInfo.Usings.Select(u => $"using {u};"))}

namespace {classInfo.Namespace};

public partial class {classInfo.ClassName}
{{
	private class {classInfo.ClassName}Properties
	{{
						
		{string.Join("\n\t\t", classInfo.Properties.Select(prop => $"public {prop.Type} {prop.PropertyName} {{ get; set; }}"))}
	}}
	/// <summary> Auto-fills any properties marked as Parameter or CascadingParameter </summary>
	/// <param name=""parameters""> The parameters to fill the properties with </param>
	/// <param name=""determination""> A function that receives object of new property values from ParameterView, and returns, whether properties have changed and therefore continue with assigning new values</param>
	private void AutoFillProperties(ParameterView parameters, Func<{classInfo.ClassName}Properties, bool> determination)
	{{
		var newProperties = new {classInfo.ClassName}Properties
		{{
			{string.Join(",\n\t\t\t", classInfo.Properties.Select(prop => $"""{prop.PropertyName} = parameters.GetValueOrDefault("{prop.PropertyName}", this.{prop.PropertyName})"""))}
		}};
		if (determination(newProperties)){{
			{string.Join("\n\t\t\t", statements)}
		}}
	}}
}}
");
				//});


			}

	internal record ClassInfo
	{
		public string Namespace { get; set; }

		public string ClassName { get; set; }
		public EquatableList<AutoFillProperties.AutoFillPropertiesGeneratorOld.PropertyInfo> Properties { get; set; }
		public EquatableList<string> Usings { get; internal set; }
	}
	internal record PropertyInfo
	{
		public string PropertyName { get; set; }
		public bool IsCascading { get; set; }
		public string Type { get; set; }
	}
}